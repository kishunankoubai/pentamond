<!DOCTYPE html>

<html>
    
    <head>
        
        <meta charset = "UTF-8">
        <title>Pentamond</title>
        
        <link rel="stylesheet" href="Layout.css">
        
    </head>
    
    <body>
        
        <div id = "base"><div id = "blockBase"></div></div>
		<div id = "time"></div>
		<div id = "score"></div>
		<div id = "trick"></div>
		<div id = "trickGoal"></div>
		<div id = "lineInform"></div>
		<div id = "info"><div id = "infoTitle"></div><div id = "infoBody"></div></div>
        
        <script src = "Control.js"></script>
        <script src = "Block.js"></script>
        <script src = "Monoiamond.js"></script>
        <script src = "Pentiamond.js"></script>
        <script src = "Play.js"></script>
        <script src = "Trick.js"></script>
        <script src = "MondPanel.js"></script>
        <script src = "TrickPanel.js"></script>
        
        <script>
            
            let c = new Control;
            c.setElement();
            c.setSize();
            c.paintAll();
			c.setPage(0);
            
            let p = new Play(c);
            
            //ウインドウサイズに変更があったらすべてのサイズを計算しなおす
            window.addEventListener("resize", (e) => {c.setSize();});
           
            //Keyの処理及びそのリピート
            let repeatFunction;
            let repeatTime = 35;
            let delayTime = 160;
            let timeoutId;
            let intervalId;
            let repeatKey;
            
            document.addEventListener("keydown", (e) => {        
                if(!e.repeat){
                    startInput(e.code);
                }                    
            });

            document.addEventListener("keyup", (e) => {
                if(e.code == repeatKey){
                    endInput(e.code);
                }                            
            });

            function startInput(kind){
                switch(kind){
                
                case "ArrowRight":
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    p.moveRight();
                    repeatKey = kind;                                
                    repeatFunction = () => {p.moveRight()}
                    timeoutId = setTimeout(() => (intervalId = setInterval(repeatFunction, repeatTime)), delayTime);
                    break;
                
                case "ArrowLeft":
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    p.moveLeft();
                    repeatKey = kind;                                
                    repeatFunction = () => {p.moveLeft()}
                    timeoutId = setTimeout(() => (intervalId = setInterval(repeatFunction, repeatTime)), delayTime);
                    break;
                    
                case "ArrowUp":
                    
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    repeatFunction = undefined;
                    p.put();
                    break;
                    
                case "ArrowDown":
                    
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    p.fall();
                    repeatKey = kind;                                
                    repeatFunction = () => {p.fall()}
                    timeoutId = setTimeout(() => (intervalId = setInterval(repeatFunction, repeatTime)), delayTime);
                    break;
                    
                case "KeyV":
                    
                    p.spinRight();
                    break;
                    
                case "KeyC":
                    
                    p.spinLeft();
                    break;

                case "KeyB":
                    
                    p.unPut();
                    break;
                    
                case "KeyS":
                    
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    repeatFunction = undefined;
                    p.start();
                    break;
                    
                case "KeyR":
                    
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    repeatFunction = undefined;
                    p.reset();
                    break;
                    
                case "KeyP":
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    repeatFunction = undefined;
                    if(p.pausing){
                        
                        p.reopening();
                        
                    }else{
                        
                        p.pause();
                        
                    }
                    
                    break;

                case "KeyA":
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    repeatFunction = undefined;
                    if(p.pausing){
                        break;
                    }
                    p.pause();
                    let mode = p.mode;
                    p.reset();
                    p.mode = mode;
                    p.start();
                    break;
                    
                case "Space":
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    repeatFunction = undefined;
                    p.hold();
                    break;
                    
                case "Enter":
                    
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    repeatFunction = undefined;
                    p.removeLine();
                    break;
                    
                }

            }

            function endInput(kind){

                switch(kind){
                
                case "ArrowRight":
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    repeatFunction = undefined;
                    break;
                
                case "ArrowLeft":
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    repeatFunction = undefined;
                    break;
                    
                case "ArrowUp":
                    break;
                    
                case "ArrowDown":
                    clearInterval(intervalId);
                    clearTimeout(timeoutId);
                    repeatFunction = undefined;
                    break;
                    
                case "KeyV":
                    
                    break;
                    
                case "KeyC":
                    
                    break;

                case "KeyB":
                    
                    break;
                    
                case "KeyS":
                    
                    break;
                    
                case "KeyR":
                    
                    break;
                    
                case "KeyP":
                    
                    break;

                case "KeyA":
                    
                case "Space":
                    break;
                    
                case "Enter":
                    break;
                    
                }

            }
            //コントローラーの接続時の処理
			
            let af;
            let num1;
            let num2;
            let sensitivity = 0.8;
            let pressedButtons = [...Array(num1)].map((i, j) => j).map(() => (false));
            let axes = [...Array(num2)].map((i, j) => j).map(() => (false))

            window.addEventListener("gamepadconnected", (e) => {
                af = window.requestAnimationFrame(gamepadLoop);
                num1 = navigator.getGamepads()[0].buttons.length;
                num2 = navigator.getGamepads()[0].axes.length;
                console.log("gamepad connected");
            });
            window.addEventListener("gamepaddisconnected", (e) => {
                window.cancelAnimationFrame(af);
                console.log("gamepad disconnected");
            });


            function gamepadLoop(){
                let gp = navigator.getGamepads()[0];

                if(!gp){
                    return;
                }

                for(i = 0; i < num1; i++){

                    if(pressedButtons[i] != gp.buttons[i].pressed){
                        if(gp.buttons[i].pressed){
                            //ここはkeydownとほぼ同様の挙動をする
                            console.log("button" + i);

                            if(i == 0){
                                p.spinLeft();
                            }

                            if(i == 1){
                                p.spinRight();
                            }

                            if(i == 3){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                repeatFunction = undefined;
                                p.removeLine();
                            }

                            if(i == 7){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                repeatFunction = undefined;
                                p.put();
                            }
                            if(i == 2){
                                p.hold();
                            }
                            if(i == 9){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                repeatFunction = undefined;
                                if(p.pausing){
                                    
                                    p.reopening();
                                    
                                }else{
                                    
                                    p.pause();
                                    
                                }
                            }
                            if(i == 13){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                p.fall();
                                repeatFunction = () => {p.fall();}
                                timeoutId = setTimeout(() => (intervalId = setInterval(repeatFunction, repeatTime)), delayTime);
                            }
                            if(i == 14){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                p.moveLeft();
                                //repeatKey = e.code;
                                repeatFunction = () => {p.moveLeft()}
                                timeoutId = setTimeout(() => (intervalId = setInterval(repeatFunction, repeatTime)), delayTime);
                            }
                            if(i == 15){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                p.moveRight();
                                //repeatKey = e.code;
                                repeatFunction = () => {p.moveRight()}
                                timeoutId = setTimeout(() => (intervalId = setInterval(repeatFunction, repeatTime)), delayTime);
                            }

                        }else{
                            //ここはkeyupと同様の挙動をする

                            if(i == 13){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                repeatFunction = undefined;
                                pressedButtons = [...Array(num1)].map((i, j) => j).map(() => (false))
                            }
                            if(i == 14){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                repeatFunction = undefined;
                                pressedButtons = [...Array(num1)].map((i, j) => j).map(() => (false))
                            }
                            if(i == 15){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                repeatFunction = undefined;
                                pressedButtons = [...Array(num1)].map((i, j) => j).map(() => (false));
                            }
                        }

                    }

                }
                for(i = 0; i < num2; i++){

                    if(Math.abs(axes[i]) < sensitivity && Math.abs(gp.axes[i]) >= sensitivity){
                        if(gp.axes[i] > 0){
                            if(i == 0){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                p.moveRight();
                                //repeatKey = e.code;                                
                                repeatFunction = () => {p.moveRight()}
                                timeoutId = setTimeout(() => (intervalId = setInterval(repeatFunction, repeatTime)), delayTime);
                            }
                            if(i == 1){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                p.fall();
                                //repeatKey = e.code;                                
                                repeatFunction = () => {p.fall();}
                                timeoutId = setTimeout(() => (intervalId = setInterval(repeatFunction, repeatTime)), delayTime);
                            }

                        }else{
                            if(i == 0){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                p.moveLeft();
                                //repeatKey = e.code;
                                repeatFunction = () => {p.moveLeft()}
                                timeoutId = setTimeout(() => (intervalId = setInterval(repeatFunction, repeatTime)), delayTime);

                            }

                        }
                    }
                    if(Math.abs(axes[i]) >= sensitivity && Math.abs(gp.axes[i]) < sensitivity){
                        if(gp.axes[i] > 0){
                            if(i == 0){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                repeatFunction = undefined;
                            }
                            if(i == 1){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                repeatFunction = undefined;
                            }

                        }else{
                            if(i == 0){
                                clearInterval(intervalId);
                                clearTimeout(timeoutId);
                                repeatFunction = undefined;
                            }
                            
                        }
                    }
                }
                pressedButtons = [...Array(num1)].map((i, j) => j).map((e) => (gp.buttons[e].pressed));
                axes = [...Array(num2)].map((i, j) => j).map((e) => (gp.axes[e]));
                if(gp.buttons[0].pressed){
                    
                }
                af = window.requestAnimationFrame(gamepadLoop);
            }

			document.getElementById("mode0").onclick = function(){p.mode = 0; p.start();};
			document.getElementById("help").onclick = function(){c.setPage(1);};
			document.getElementById("modeSelect").onclick = function(){c.setPage(2);};
			document.getElementById("mode1").onclick = function(){p.mode = 1; p.start();};
			document.getElementById("mode2").onclick = function(){p.mode = 2; p.start();};
			document.getElementById("mode3").onclick = function(){p.mode = 3; p.start();};
			document.getElementById("reset").onclick = function(){p.reset();};
			document.getElementById("howToPlay").onclick = function(){c.setPage(3);};
			document.getElementById("howToOperate").onclick = function(){c.setPage(4);};
			document.getElementById("trickList").onclick = function(){c.setPage(5);};
			document.getElementById("next").onclick = function(){c.nextTrick();};
			document.getElementById("prev").onclick = function(){c.prevTrick();};
			
			document.getElementById("return0").onclick = function(){c.setPage(0);};
			document.getElementById("return1").onclick = function(){c.setPage(1);};
			
			document.getElementById("reopening").onclick = function(){p.reopening();};
			document.getElementById("retry").onclick = function(){let mode = p.mode; p.reset(); p.mode = mode; p.start();};
			document.getElementById("returnToTop").onclick = function(){p.reset();};
            
        </script>
        
    </body>
    
</html>